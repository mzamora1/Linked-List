(()=>{"use strict";var __webpack_modules__={44:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval("\n;// CONCATENATED MODULE: ./src/state.ts\nvar algorithms;\r\n(function (algorithms) {\r\n    algorithms[algorithms[\"mergeSort\"] = 0] = \"mergeSort\";\r\n    algorithms[algorithms[\"bubbleSort\"] = 1] = \"bubbleSort\";\r\n})(algorithms || (algorithms = {}));\r\n//takes an object and exposes it through get or set function\r\n//ensures state is always up to date throughout the app\r\nconst { get, set, pause } = function loadState(state) {\r\n    const get = (key) => state[key];\r\n    const set = (key, value) => void (state[key] = value);\r\n    const pause = function makePause() {\r\n        const pauseBtn = document.querySelector('button#pause');\r\n        pauseBtn.onclick = () => state.isPaused = true;\r\n        return () => state.isPaused && new Promise((resolve) => {\r\n            pauseBtn.textContent = 'START';\r\n            pauseBtn.onclick = () => {\r\n                state.isPaused = false;\r\n                resolve(true);\r\n                pauseBtn.textContent = 'PAUSE';\r\n                console.log('unpaused');\r\n                pauseBtn.onclick = () => state.isPaused = true;\r\n            };\r\n        });\r\n    }();\r\n    return { get, set, pause };\r\n}(\r\n//this object can only be accessed through get, set, pause functions\r\nnew class State {\r\n    constructor() {\r\n        this.domIsRunning = false;\r\n        this.canvasIsRunning = false;\r\n        this.speed = 700;\r\n        this.isPaused = false;\r\n        this.algorithm = null;\r\n        this.numOfBars = 50;\r\n    }\r\n});\r\n\n;// CONCATENATED MODULE: ./src/utils.ts\nclass HSL {\r\n    constructor(hue, saturation, lightness = 0) {\r\n        this.hue = hue;\r\n        this.saturation = saturation;\r\n        this.lightness = lightness;\r\n        this.color = '';\r\n        this.setColor({ hue, saturation, lightness });\r\n    }\r\n    setColor({ hue, saturation, lightness }) {\r\n        return this.color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;\r\n    }\r\n    reset() {\r\n        return this.color = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness}%)`;\r\n    }\r\n}\r\nconst sleep = (ms) => new Promise(res => setTimeout(res, ms));\r\nconst error = (msg) => {\r\n    throw new Error(msg);\r\n};\r\n//factory for manipulating element classLists\r\n//used in index.ts\r\nconst make = (arrayAction) => (action, className, orFunc) => (...elements) => elements[arrayAction](element => element.classList[action](className) || (orFunc === null || orFunc === void 0 ? void 0 : orFunc(element)));\r\nconst addElement = (parent, tag, { textContent, className, id }) => {\r\n    const newElement = document.createElement(tag);\r\n    if (textContent)\r\n        newElement.textContent = textContent;\r\n    if (className)\r\n        newElement.classList.add(className);\r\n    if (id)\r\n        newElement.id = id;\r\n    parent.append(newElement);\r\n    return newElement;\r\n};\r\nconst map = (value, a, b, c, d) => {\r\n    const temp = (value - a) / (b - a); // first map value from (a..b) to (0..1)\r\n    return Math.round(c + temp * (d - c)); // then map it from (0..1) to (c..d) and return it\r\n};\r\n\r\n\n;// CONCATENATED MODULE: ./src/domLinkedList.ts\n\r\n\r\nconst cloneNode = function makeCloneNode() {\r\n    let source;\r\n    (function (source) {\r\n        source[source[\"kanyeRest\"] = 0] = \"kanyeRest\";\r\n        source[source[\"dataJokes\"] = 1] = \"dataJokes\";\r\n    })(source || (source = {}));\r\n    ;\r\n    let content = [].values();\r\n    let currentSource;\r\n    const setContent = function makeSetContent() {\r\n        const getDadJokesUrl = () => 'https://icanhazdadjoke.com/search?page=' + Math.round(Math.random() * 15);\r\n        const kanyeRestUrl = 'https://api.kanye.rest';\r\n        return async function setContent() {\r\n            const url = currentSource === source.dataJokes ? getDadJokesUrl() : kanyeRestUrl;\r\n            const response = await fetch(url, {\r\n                headers: {\r\n                    'User-Agent': 'Linked List Visualization (https://github.com/mzamora1/repo)',\r\n                    'Accept': 'application/json'\r\n                },\r\n                method: 'GET'\r\n            });\r\n            const json = await response.json();\r\n            if ('results' in json) {\r\n                return content = json.results.map(({ joke }) => joke).values();\r\n            }\r\n            else\r\n                return content = [json.quote].values();\r\n        };\r\n    }();\r\n    void function setDropwDownHandler() {\r\n        const dropdown = document.querySelector('select');\r\n        dropdown.onchange = function () {\r\n            currentSource = +dropdown.value;\r\n            while (content.next().value)\r\n                ;\r\n            setContent();\r\n        };\r\n    }();\r\n    addEventListener('load', setContent, { once: true });\r\n    const template = document.querySelector('template#node').content;\r\n    return async function cloneNode() {\r\n        const clone = template.firstElementChild.cloneNode(true);\r\n        const title = clone.querySelector('span.data-title');\r\n        const dataSpan = clone.querySelector('span.node-data');\r\n        const { done, value } = content.next();\r\n        if (done) {\r\n            await setContent();\r\n            dataSpan.textContent = content.next().value;\r\n        }\r\n        else\r\n            dataSpan.textContent = value;\r\n        title.textContent = currentSource === source.dataJokes ? 'Dad Joke: ' : 'Kanye Quote: ';\r\n        return clone;\r\n    };\r\n}(); //end of makeCloneNode\r\nconst domLinkedList = function createDOMLinkedList() {\r\n    const toggle = async (element, classes, ms) => {\r\n        classes.forEach(c => element.classList.toggle(c));\r\n        await pause();\r\n        await sleep(ms);\r\n        classes.forEach(c => element.classList.toggle(c));\r\n    };\r\n    return new class DOMLinkedList {\r\n        constructor() {\r\n            this.figure = document.querySelector('figure#linkedList');\r\n            this.head = this.figure.querySelector('#head');\r\n            this.end = this.figure.querySelector('.null');\r\n            this.searchContainer = this.figure.querySelector('#searchResult');\r\n            this.length = 0;\r\n            this.searchContainer.onclick = e => {\r\n                e.stopPropagation();\r\n                this.searchContainer.classList.remove('visible');\r\n            };\r\n        }\r\n        *[Symbol.iterator]() {\r\n            for (const node of this.figure.children) {\r\n                if (!get('domIsRunning'))\r\n                    return console.log('not running');\r\n                if (!node.classList.contains('node') || node === this.head)\r\n                    continue;\r\n                yield node;\r\n            }\r\n        }\r\n        async *[Symbol.asyncIterator]() {\r\n            for (const node of this) {\r\n                await toggle(node, ['active'], get('speed'));\r\n                yield node;\r\n            }\r\n        }\r\n        async insert(target) {\r\n            const clone = await cloneNode();\r\n            switch (target) {\r\n                case this.head:\r\n                    this.head.after(clone);\r\n                    await toggle(clone, ['new'], get('speed') * 0.5);\r\n                    break;\r\n                case this.end.previousElementSibling:\r\n                case this.figure:\r\n                    this.end.before(clone);\r\n                    await toggle(clone, ['new'], get('speed') * 0.5);\r\n                    break;\r\n                default:\r\n                    for await (const node of this) {\r\n                        if (node === target) {\r\n                            node.after(clone);\r\n                            await toggle(clone, ['new'], get('speed') * 1.25);\r\n                            break;\r\n                        }\r\n                    }\r\n            }\r\n            this.length++;\r\n        }\r\n        async delete(target) {\r\n            if (this.head.nextElementSibling === this.end)\r\n                return;\r\n            if (target === this.head)\r\n                target = this.head.nextElementSibling;\r\n            else if (target === this.figure)\r\n                target = this.end.previousElementSibling;\r\n            for await (const node of this) {\r\n                if (node === target) {\r\n                    await toggle(node, ['remove'], get('speed') * 1.25);\r\n                    node.remove();\r\n                    break;\r\n                }\r\n            }\r\n            this.length--;\r\n        }\r\n        async search(target) {\r\n            switch (target) {\r\n                case this.head:\r\n                    target = this.head.nextElementSibling;\r\n                    break;\r\n                case this.end:\r\n                    target = this.end.previousElementSibling;\r\n                    break;\r\n                case this.figure:\r\n                    target = null;\r\n                    break;\r\n            }\r\n            for await (const node of this) {\r\n                if (node === target) {\r\n                    this.searchContainer.classList.add('visible');\r\n                    return this.searchContainer.firstElementChild.textContent = node.querySelector('span.node-data').textContent;\r\n                }\r\n            }\r\n        }\r\n        async sort(func) {\r\n            for (let last = this.length - 1; last > 0; last--) {\r\n                let i = 0;\r\n                for (const node of this) {\r\n                    if (i++ > last)\r\n                        break;\r\n                    const nextNode = node.nextElementSibling;\r\n                    toggle(node, ['active'], get('speed'));\r\n                    await toggle(nextNode, ['new'], get('speed'));\r\n                    const nextSpan = nextNode.querySelector('span');\r\n                    if (nextSpan && func(node, nextNode)) {\r\n                        const span = node.querySelector('span');\r\n                        const temp = span.textContent;\r\n                        span.textContent = nextSpan.textContent;\r\n                        nextSpan.textContent = temp;\r\n                        toggle(node, ['new'], get('speed') * 1.25);\r\n                        await toggle(nextNode, ['active'], get('speed') * 1.25);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }; //end of DOMLinkedList \r\n}(); // end of createDOMLinkedList\r\n/* harmony default export */ const src_domLinkedList = (domLinkedList);\r\n\n;// CONCATENATED MODULE: ./src/style.ts\n\r\n\r\n//represents a bar inside the canvas element\r\n//used in canvasLinkedList.ts\r\nclass Bar {\r\n    constructor(canvas, color) {\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.x = 0;\r\n        this.random = Math.random();\r\n        this.resize(canvas);\r\n        const lightness = map(this.width, 0, canvas.width, 5, 95);\r\n        this.hsl = new HSL(color.hue, color.saturation, lightness);\r\n    }\r\n    resize({ width, height }) {\r\n        this.width = this.random * width;\r\n        this.height = height / get('numOfBars');\r\n        this.x = (width / 2) - (this.width / 2);\r\n    }\r\n}\r\n//used in canvasLinkedList.ts, curryStyle\r\nconst drawFrame = function makeDrawFrame(canvas) {\r\n    //const canvas = document.querySelector('canvas')!\r\n    const ctx = canvas.getContext('2d');\r\n    return function drawFrame(list) {\r\n        ctx.fillStyle = 'rgb(0,0,0)';\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n        let index = 0;\r\n        for (let bar = list.head; bar !== null; bar = bar.next) {\r\n            const { hsl, x, height, width } = bar.data;\r\n            ctx.fillStyle = hsl.color;\r\n            ctx.fillRect(x, height * index++, width, height);\r\n        }\r\n    };\r\n}(document.querySelector('canvas'));\r\n//factory function for styling bars\r\n//used in sort.ts\r\nconst curryStyle = function makeCurry(colors) {\r\n    return function curryStyle(getTimeOfDelay, dontReset = false) {\r\n        return async function style(node, next, listToDraw) {\r\n            if (!get('canvasIsRunning'))\r\n                return;\r\n            node.data.hsl.setColor(colors[0]);\r\n            next === null || next === void 0 ? void 0 : next.data.hsl.setColor(colors[1]);\r\n            const promiseOrFalse = pause();\r\n            if (promiseOrFalse)\r\n                await promiseOrFalse;\r\n            if (listToDraw) {\r\n                //console.log(listToDraw)\r\n                drawFrame(listToDraw);\r\n            }\r\n            await sleep(getTimeOfDelay());\r\n            if (dontReset)\r\n                return;\r\n            node.data.hsl.reset();\r\n            next === null || next === void 0 ? void 0 : next.data.hsl.reset();\r\n        };\r\n    };\r\n    //first: purple, second: green\r\n}([new HSL(300, 100, 50), new HSL(152, 100, 50)]);\r\n\n;// CONCATENATED MODULE: ./src/linkedList.ts\nconst isInBounds = function (self, ...indexes) {\r\n    const { length } = self;\r\n    for (const index of indexes) {\r\n        if (index < 0 || index >= length) {\r\n            throw new RangeError(`Index: ${index} is out of bounds Length: ${length}`);\r\n        }\r\n    }\r\n    return true;\r\n};\r\nclass Base {\r\n}\r\nclass LinkedListNode {\r\n    constructor(data, next = null) {\r\n        this.data = data;\r\n        this.next = next;\r\n    }\r\n    *[Symbol.iterator]() {\r\n        for (let current = this; current !== null; current = current.next) {\r\n            yield current;\r\n        }\r\n    }\r\n    get length() {\r\n        let length = 0;\r\n        for (const _ of this)\r\n            length++;\r\n        return length;\r\n    }\r\n    copy(end = Infinity) {\r\n        if (end === 0)\r\n            return new LinkedListNode(undefined);\r\n        let index = 0;\r\n        const clone = (node) => {\r\n            return node === null || index++ >= end ? null : new LinkedListNode(node.data, clone(node.next));\r\n        };\r\n        return clone(this);\r\n    }\r\n    toString() {\r\n        return `Data: ${this.data}`;\r\n    }\r\n} // end of LinkedListNode\r\nclass LinkedList {\r\n    constructor(...args) {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.length = 0;\r\n        if (args.length)\r\n            this.add(...args);\r\n    }\r\n    *[Symbol.iterator]() {\r\n        for (let current = this.head; current !== null; current = current.next) {\r\n            yield current;\r\n        }\r\n    }\r\n    copy(start = 0, end = Infinity) {\r\n        if (end < start)\r\n            throw new RangeError(`start must be less than end\\n\\t\\tStart: ${start}\\tEnd: ${end}`);\r\n        if (end <= start || !this.head)\r\n            return new LinkedList();\r\n        return new LinkedList(...this.get(start).copy(end));\r\n    }\r\n    join(...iterables) {\r\n        for (const iterable of iterables) {\r\n            if (Symbol.iterator in Object(iterable)) {\r\n                this.add(...iterable);\r\n            }\r\n            else\r\n                this.add(iterable);\r\n        }\r\n        return this;\r\n    }\r\n    addFirst(...args) {\r\n        var _a;\r\n        for (const data of args) {\r\n            if (data instanceof LinkedListNode)\r\n                this.head = new LinkedListNode(data.data, this.head);\r\n            else\r\n                this.head = new LinkedListNode(data, this.head);\r\n            (_a = this.tail) !== null && _a !== void 0 ? _a : (this.tail = this.head);\r\n            this.length++;\r\n        }\r\n        return this;\r\n    }\r\n    add(...args) {\r\n        for (const data of args) {\r\n            if (this.tail) {\r\n                if (data instanceof LinkedListNode)\r\n                    this.tail.next = new LinkedListNode(data.data);\r\n                else\r\n                    this.tail.next = new LinkedListNode(data);\r\n                this.tail = this.tail.next;\r\n                this.length++;\r\n            }\r\n            else\r\n                this.addFirst(data);\r\n        }\r\n        return this;\r\n    }\r\n    forEach(func) {\r\n        let index = 0;\r\n        for (const node of this) {\r\n            func(node, index++);\r\n        }\r\n    }\r\n    find(func) {\r\n        let index = 0;\r\n        for (const node of this) {\r\n            const response = func(node, index++);\r\n            if (response !== undefined && response !== false) {\r\n                return response;\r\n            }\r\n        }\r\n    }\r\n    indexOf(node) {\r\n        const index = this.find((n, index) => n === node && index);\r\n        return index === undefined ? -1 : index;\r\n    }\r\n    get(index) {\r\n        isInBounds(this, index);\r\n        return this.find((node, i) => i === index && node);\r\n    }\r\n    insert(index, data) {\r\n        isInBounds(this, index);\r\n        switch (index) {\r\n            case 0: return this.addFirst(data);\r\n            case this.length - 1: return this.add(data);\r\n            default: {\r\n                const node = this.get(index);\r\n                node.next = new LinkedListNode(data, node.next);\r\n                return this;\r\n            }\r\n        }\r\n    }\r\n    removeHead() {\r\n        if (!this.head)\r\n            throw new ReferenceError('cannot remove from empty list');\r\n        const removed = this.head;\r\n        this.head = this.head.next;\r\n        this.length--;\r\n        return removed;\r\n    }\r\n    clear() {\r\n        while (this.head)\r\n            this.head = this.head.next;\r\n        this.tail = null;\r\n        this.length = 0;\r\n        return this;\r\n    }\r\n    remove(indexOrNode) {\r\n        if (indexOrNode instanceof LinkedListNode) {\r\n            const index = this.indexOf(indexOrNode);\r\n            return this.remove(index);\r\n        }\r\n        isInBounds(this, indexOrNode);\r\n        if (indexOrNode === 0)\r\n            return this.removeHead();\r\n        else {\r\n            const node = this.get(indexOrNode - 1);\r\n            const removed = node.next;\r\n            node.next = removed.next;\r\n            this.length--;\r\n            return removed;\r\n        }\r\n    }\r\n    filter(func) {\r\n        let index = 0;\r\n        let previous;\r\n        for (let current = this.head; current !== null; current = current.next, index++) {\r\n            if (func(current, index)) {\r\n                if (index === 0)\r\n                    this.head = current.next;\r\n                else {\r\n                    previous.next = current.next;\r\n                    if (current === this.tail)\r\n                        this.tail = previous;\r\n                    current = previous;\r\n                }\r\n                this.length--, index--;\r\n            }\r\n            previous = current;\r\n        }\r\n        return this;\r\n    }\r\n    map(func) {\r\n        const newList = new LinkedList();\r\n        this.forEach((node, index) => {\r\n            var _a, _b;\r\n            const response = func(node, index);\r\n            if (response !== undefined) {\r\n                newList.add((_b = (_a = response) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : response);\r\n            }\r\n        });\r\n        return newList;\r\n    }\r\n    toString() {\r\n        let string = '', count = 1;\r\n        for (const node of this) {\r\n            string += `${node.data} ${count++ === this.length ? '\\n' : '==>'} `;\r\n        }\r\n        string += `\\n%cLength: ${this.length}\\n`;\r\n        console.log(string, 'font-weight: bold;');\r\n        return string;\r\n    }\r\n    swap(a, b) {\r\n        const temp = a.data;\r\n        a.data = b.data;\r\n        b.data = temp;\r\n        return this;\r\n    }\r\n} // end of LinkedList\r\nconst empty = new LinkedList();\r\nconst balls = { balls: 0 };\r\nempty.add('im a string', 4, balls);\r\nconsole.log(empty);\r\nconst arr = Array(20).fill(1).map(v => v = Math.round(Math.random() * 20));\r\nconst obj = {};\r\nconst list = new LinkedList(...arr);\r\nconsole.log(list.tail);\r\nconsole.log(list.remove(list.tail));\r\nconsole.log(list.length, list.copy(0));\r\nconst clone = list.copy(1);\r\nconst linkedList_map = list.map(node => node);\r\nconsole.log(clone, linkedList_map);\r\nlist.toString();\r\nlist.filter(node => node.data === 6);\r\n//list.toString();\r\nlist.join(list).toString();\r\n\n;// CONCATENATED MODULE: ./src/sort.ts\n\r\n\r\n\r\nconst fastStyle = curryStyle(() => get('speed') * 0.25);\r\nconst bubbleSort = async (list) => {\r\n    const slowStyle = curryStyle(() => get('speed') * 0.35);\r\n    for (let i = list.length; i > 1; i--) {\r\n        let j = 0;\r\n        for (const node of list) {\r\n            if (!get('canvasIsRunning'))\r\n                return console.log('stopped early');\r\n            if (++j >= i)\r\n                break;\r\n            await fastStyle(node, node.next);\r\n            if (node.data.width > node.next.data.width) {\r\n                list.swap(node, node.next);\r\n                await slowStyle(node.next, node);\r\n            }\r\n        }\r\n    }\r\n};\r\nconst mergeSort = async (list) => {\r\n    const reallyFastStyle = curryStyle(() => get('speed') * 0.15);\r\n    const reallySlowStyle = curryStyle(() => get('speed') * 0.5);\r\n    const getMiddle = (node) => {\r\n        var _a;\r\n        if (!node)\r\n            return null;\r\n        let slow = node, fast = node;\r\n        while ((_a = fast.next) === null || _a === void 0 ? void 0 : _a.next) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return slow;\r\n    };\r\n    const merge = async (a, b) => {\r\n        if (!a)\r\n            return b;\r\n        if (!b)\r\n            return a;\r\n        let result = null;\r\n        if (a.data.width <= b.data.width) {\r\n            result = a;\r\n            await fastStyle(result, b, new LinkedList(...a).join(b));\r\n            result.next = await merge(a.next, b);\r\n        }\r\n        else {\r\n            result = b;\r\n            await fastStyle(result, a, new LinkedList(...a).join(b));\r\n            result.next = await merge(a, b.next);\r\n        }\r\n        await reallyFastStyle(result, undefined, new LinkedList(...result));\r\n        return result;\r\n    };\r\n    const mergeSort = async (node) => {\r\n        if (!(node === null || node === void 0 ? void 0 : node.next))\r\n            return node;\r\n        const left = node;\r\n        const middle = getMiddle(node);\r\n        const right = middle.next;\r\n        middle.next = null;\r\n        await reallySlowStyle(middle, left, new LinkedList(...node));\r\n        return await merge(await mergeSort(left), await mergeSort(right));\r\n    };\r\n    const head = await mergeSort(list.head);\r\n    if (get('canvasIsRunning')) {\r\n        list.head = head;\r\n        console.log('done!', list);\r\n    }\r\n    else\r\n        console.log('stopped early');\r\n};\r\n\n;// CONCATENATED MODULE: ./src/canvasLinkedList.ts\n\r\n\r\n\r\n\r\n\r\nconst figure = document.querySelector('figure.canvasContainer');\r\nconst linkedList = new LinkedList();\r\nconst refresh = function makeRefresh(canvas, figure) {\r\n    return function refresh() {\r\n        set('canvasIsRunning', false);\r\n        linkedList.clear();\r\n        const { width, height } = figure.getBoundingClientRect();\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        for (let i = 0; i < get('numOfBars'); i++) {\r\n            linkedList.add(new Bar(canvas, new HSL(183, 76.5)));\r\n        }\r\n    };\r\n}(figure.querySelector('canvas'), figure);\r\nconst startCanvas = function makeStartCanvas() {\r\n    const sortInstructions = document.querySelector('#sortInstructions');\r\n    const startDelay = 1500;\r\n    let timeOfLastStart = 0;\r\n    return async function startCanvas() {\r\n        if (Date.now() - timeOfLastStart <= startDelay)\r\n            return;\r\n        timeOfLastStart = Date.now();\r\n        sortInstructions.classList.remove('visible');\r\n        refresh();\r\n        drawFrame(linkedList);\r\n        await sleep(startDelay);\r\n        await pause();\r\n        set('canvasIsRunning', true);\r\n        const sortFunc = get('algorithm') === algorithms.mergeSort ? mergeSort : bubbleSort;\r\n        if (sortFunc.name !== 'mergeSort') {\r\n            const draw = () => {\r\n                if (!get('canvasIsRunning'))\r\n                    return console.log('stopped early');\r\n                drawFrame(linkedList);\r\n                requestAnimationFrame(draw);\r\n            };\r\n            draw();\r\n        }\r\n        await sortFunc(linkedList);\r\n        if (!get('canvasIsRunning'))\r\n            return;\r\n        set('canvasIsRunning', false);\r\n        drawFrame(linkedList);\r\n    };\r\n}();\r\n/* harmony default export */ const canvasLinkedList = (startCanvas);\r\n\n;// CONCATENATED MODULE: ./src/index.ts\n\r\n\r\n\r\n\r\n\r\n__webpack_require__.e(/* import() */ 388).then(__webpack_require__.t.bind(__webpack_require__, 388, 23)).then((particles) => {\r\n    const global = window;\r\n    global.particlesJS.load('particles', 'particles.json');\r\n    const observer = new IntersectionObserver(entries => {\r\n        var _a;\r\n        if (!((_a = global.pJSDom[0]) === null || _a === void 0 ? void 0 : _a.pJS))\r\n            return;\r\n        entries.forEach(entry => {\r\n            if (entry.isIntersecting) {\r\n                global.pJSDom[0].pJS.particles.move.enable = false;\r\n                console.count('paused');\r\n            }\r\n            else {\r\n                global.pJSDom[0].pJS.particles.move.enable = true;\r\n                global.pJSDom[0].pJS.fn.particlesRefresh();\r\n            }\r\n        });\r\n    }, { root: null, rootMargin: '0px', threshold: 0.75 });\r\n    observer.observe(src_domLinkedList.figure);\r\n});\r\nvoid function setGlobalHandlers() {\r\n    void function setSpeedInputHandler() {\r\n        const speedSlider = document.querySelector('#speed');\r\n        speedSlider.onchange = () => set('speed', +speedSlider.value);\r\n    }();\r\n    void function setBarInputHandler() {\r\n        const barInput = document.querySelector('#bar-input');\r\n        barInput.onchange = function () {\r\n            set('numOfBars', +barInput.value);\r\n            if (get('algorithm') !== null)\r\n                canvasLinkedList();\r\n        };\r\n    }();\r\n    const makeForEach = make('forEach');\r\n    const show = makeForEach('add', 'visible'), hide = makeForEach('remove', 'visible'), activate = makeForEach('add', 'active'), deactivate = makeForEach('remove', 'active'), findActiveIndex = make('findIndex')('contains', 'active');\r\n    const sortInput = document.querySelector('#algorithms');\r\n    const sortInstructions = document.querySelector('#sortInstructions');\r\n    void function setAlgorithmInputHandler() {\r\n        const sortButtons = sortInput.querySelector('#sortContainer');\r\n        sortButtons.onclick = ({ target }) => {\r\n            if (target === sortButtons)\r\n                return;\r\n            hide(sortInstructions);\r\n            const indexOfOldActive = findActiveIndex(...sortButtons.children);\r\n            if (indexOfOldActive !== -1)\r\n                deactivate(sortButtons.children[indexOfOldActive]);\r\n            const newActiveBtn = target;\r\n            activate(newActiveBtn);\r\n            set('algorithm', findActiveIndex(...sortButtons.children));\r\n            canvasLinkedList();\r\n        };\r\n    }();\r\n    void function setMainHandlers() {\r\n        const apiInput = document.querySelector('#api');\r\n        const barInput = document.querySelector('#bars');\r\n        const insturctions = src_domLinkedList.figure.querySelector('#mainInstructions');\r\n        const nav = document.querySelector('nav');\r\n        void function setNavHandler() {\r\n            const isClicked = [];\r\n            const sortButton = nav.children[3];\r\n            sortButton.onclick = () => {\r\n                hide(src_domLinkedList.figure);\r\n                show(figure, sortInput, sortInstructions, barInput);\r\n            };\r\n            activate(nav.children[0]);\r\n            show(insturctions, insturctions.children[0]);\r\n            nav.onclick = ({ target }) => {\r\n                if (target === nav)\r\n                    return;\r\n                set('isPaused', false);\r\n                if (target !== sortButton) {\r\n                    show(src_domLinkedList.figure);\r\n                    hide(figure, sortInput, barInput);\r\n                }\r\n                const oldActiveIndex = findActiveIndex(...nav.children);\r\n                //if list is empty and insert btn was active then dont change active btn except if user clicked on sort btn\r\n                if (src_domLinkedList.length === 0 && oldActiveIndex === 0 && target !== sortButton)\r\n                    return;\r\n                hide(src_domLinkedList.searchContainer, insturctions, insturctions.children[oldActiveIndex], apiInput);\r\n                deactivate(nav.children[oldActiveIndex]);\r\n                set('domIsRunning', false);\r\n                set('canvasIsRunning', false);\r\n                const activeBtn = target;\r\n                activate(activeBtn);\r\n                if (activeBtn === nav.children[0]) {\r\n                    show(apiInput);\r\n                }\r\n                const newIndex = findActiveIndex(...nav.children);\r\n                if (target === sortButton || isClicked.includes(newIndex))\r\n                    return;\r\n                isClicked.push(newIndex);\r\n                show(insturctions, insturctions.children[newIndex]);\r\n            };\r\n        }(); //end of setNavHandler\r\n        void function setLinkedListHandler() {\r\n            const findTarget = make('find')('contains', 'node', element => element === src_domLinkedList.figure);\r\n            src_domLinkedList.figure.onclick = async (e) => {\r\n                if (get('domIsRunning'))\r\n                    return;\r\n                if (insturctions.classList.contains('visible'))\r\n                    return hide(insturctions);\r\n                const target = findTarget(...e.composedPath());\r\n                set('domIsRunning', true);\r\n                switch (findActiveIndex(...nav.children)) {\r\n                    case 0:\r\n                        await src_domLinkedList.insert(target);\r\n                        break;\r\n                    case 1:\r\n                        await src_domLinkedList.delete(target);\r\n                        break;\r\n                    case 2:\r\n                        await src_domLinkedList.search(target);\r\n                        break;\r\n                    case 3: await src_domLinkedList.sort((node, next) => {\r\n                        if (document.body.clientWidth > 800) {\r\n                            return node.clientWidth > next.clientWidth;\r\n                        }\r\n                        else {\r\n                            const firstData = node.querySelector('.node-data').textContent, secondData = next.querySelector('.node-data').textContent;\r\n                            return firstData.split(' ').length > secondData.split(' ').length;\r\n                        }\r\n                    });\r\n                }\r\n                set('domIsRunning', false);\r\n            };\r\n        }(); //end of setLinkedListHandler\r\n    }(); //end of setMainHandlers\r\n}(); //end of setGlobalHandlers\r\n\n\n//# sourceURL=webpack://linked-list/./src/index.ts_+_7_modules?")}},__webpack_module_cache__={},leafPrototypes,getProto,inProgress,dataWebpackPrefix;function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var r=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](r,r.exports,__webpack_require__),r.exports}__webpack_require__.m=__webpack_modules__,getProto=Object.getPrototypeOf?n=>Object.getPrototypeOf(n):n=>n.__proto__,__webpack_require__.t=function(n,e){if(1&e&&(n=this(n)),8&e)return n;if("object"==typeof n&&n){if(4&e&&n.__esModule)return n;if(16&e&&"function"==typeof n.then)return n}var r=Object.create(null);__webpack_require__.r(r);var t={};leafPrototypes=leafPrototypes||[null,getProto({}),getProto([]),getProto(getProto)];for(var s=2&e&&n;"object"==typeof s&&!~leafPrototypes.indexOf(s);s=getProto(s))Object.getOwnPropertyNames(s).forEach((e=>t[e]=()=>n[e]));return t.default=()=>n,__webpack_require__.d(r,t),r},__webpack_require__.d=(n,e)=>{for(var r in e)__webpack_require__.o(e,r)&&!__webpack_require__.o(n,r)&&Object.defineProperty(n,r,{enumerable:!0,get:e[r]})},__webpack_require__.f={},__webpack_require__.e=n=>Promise.all(Object.keys(__webpack_require__.f).reduce(((e,r)=>(__webpack_require__.f[r](n,e),e)),[])),__webpack_require__.u=n=>n+".35cbb16a8c98c3eef468.bundle.js",__webpack_require__.miniCssF=n=>{},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),__webpack_require__.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),inProgress={},dataWebpackPrefix="linked-list:",__webpack_require__.l=(n,e,r,t)=>{if(inProgress[n])inProgress[n].push(e);else{var s,i;if(void 0!==r)for(var o=document.getElementsByTagName("script"),a=0;a<o.length;a++){var c=o[a];if(c.getAttribute("src")==n||c.getAttribute("data-webpack")==dataWebpackPrefix+r){s=c;break}}s||(i=!0,(s=document.createElement("script")).charset="utf-8",s.timeout=120,__webpack_require__.nc&&s.setAttribute("nonce",__webpack_require__.nc),s.setAttribute("data-webpack",dataWebpackPrefix+r),s.src=n),inProgress[n]=[e];var d=(e,r)=>{s.onerror=s.onload=null,clearTimeout(l);var t=inProgress[n];if(delete inProgress[n],s.parentNode&&s.parentNode.removeChild(s),t&&t.forEach((n=>n(r))),e)return e(r)},l=setTimeout(d.bind(null,void 0,{type:"timeout",target:s}),12e4);s.onerror=d.bind(null,s.onerror),s.onload=d.bind(null,s.onload),i&&document.head.appendChild(s)}},__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},(()=>{var n;__webpack_require__.g.importScripts&&(n=__webpack_require__.g.location+"");var e=__webpack_require__.g.document;if(!n&&e&&(e.currentScript&&(n=e.currentScript.src),!n)){var r=e.getElementsByTagName("script");r.length&&(n=r[r.length-1].src)}if(!n)throw new Error("Automatic publicPath is not supported in this browser");n=n.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=n})(),(()=>{var n={179:0};__webpack_require__.f.j=(e,r)=>{var t=__webpack_require__.o(n,e)?n[e]:void 0;if(0!==t)if(t)r.push(t[2]);else{var s=new Promise(((r,s)=>t=n[e]=[r,s]));r.push(t[2]=s);var i=__webpack_require__.p+__webpack_require__.u(e),o=new Error;__webpack_require__.l(i,(r=>{if(__webpack_require__.o(n,e)&&(0!==(t=n[e])&&(n[e]=void 0),t)){var s=r&&("load"===r.type?"missing":r.type),i=r&&r.target&&r.target.src;o.message="Loading chunk "+e+" failed.\n("+s+": "+i+")",o.name="ChunkLoadError",o.type=s,o.request=i,t[1](o)}}),"chunk-"+e,e)}};var e=(e,r)=>{var t,s,[i,o,a]=r,c=0;for(t in o)__webpack_require__.o(o,t)&&(__webpack_require__.m[t]=o[t]);for(a&&a(__webpack_require__),e&&e(r);c<i.length;c++)s=i[c],__webpack_require__.o(n,s)&&n[s]&&n[s][0](),n[i[c]]=0},r=self.webpackChunklinked_list=self.webpackChunklinked_list||[];r.forEach(e.bind(null,0)),r.push=e.bind(null,r.push.bind(r))})();var __webpack_exports__=__webpack_require__(44)})();